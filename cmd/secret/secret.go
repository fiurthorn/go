package main

import (
	"bytes"
	"crypto/rand"
	_ "embed"
	"encoding/base64"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
	"time"

	"encoding/binary"

	"filippo.io/age"
	"filippo.io/age/armor"
	"golang.org/x/term"
)

const templateString = `// Code generated by 'go generate'; DO NOT EDIT.

//go:build local

package {{.PackageName}}
import(
	"filippo.io/age/armor"
	"filippo.io/age"
	_ "embed"
	"bytes"
	"io"
)

//go:embed {{.EmbedFileName}}
var {{.EncryptedVarName}} []byte

func {{.FunctionName}}() []byte {
	i, _ := age.NewScryptIdentity("{{.Key}}")
	r, _ := age.Decrypt(armor.NewReader(bytes.NewReader({{.EncryptedVarName}})), i)
	a, _ := io.ReadAll(r)
	return a
}

var {{.DecryptedVarName}} = {{.FunctionName}}()
`

type templateConfig struct {
	PackageName      string
	FunctionName     string
	Key              string
	EmbedFileName    string
	EncryptedVarName string
	DecryptedVarName string
}

func sCryptKeyGen() string {
	keybytes := make([]byte, 32)
	rand.Read(keybytes)
	return base64.RawStdEncoding.EncodeToString(keybytes)
}

func readEncryptedSecret(key string, ainf io.Reader) io.Reader {
	aof := armor.NewReader(ainf)
	idty, err := age.NewScryptIdentity(key)
	if err != nil {
		panic(err)
	}
	w, err := age.Decrypt(aof, idty)
	if err != nil {
		panic(err)
	}
	return w
}

func identity(filePath string) []age.Identity {
	file, err := os.Open(filePath)
	if err != nil {
		log.Fatalf("Failed to open private keys file: %v", err)
	}

	passphrase, err := passphrasePrompt()
	if err != nil {
		log.Fatalf("Passphrase: %v", err)
	}

	plain := readEncryptedSecret(passphrase, file)

	identities, err := age.ParseIdentities(plain)
	if err != nil {
		log.Fatalf("Failed to parse private key: %v", err)
	}
	return identities
}

func master(filePath string) []age.Identity {
	file, err := os.Open(filePath)
	if err != nil {
		log.Fatalf("Failed to open private keys file: %v", err)
	}
	identities, err := age.ParseIdentities(file)
	if err != nil {
		log.Fatalf("Failed to parse private key: %v", err)
	}
	return identities
}

func recipient(filePath string) []age.Recipient {
	file, err := os.Open(filePath)
	if err != nil {
		log.Fatalf("Failed to open private keys file: %v", err)
	}
	recipient, err := age.ParseRecipients(file)
	if err != nil {
		log.Fatalf("Failed to parse private key: %v", err)
	}
	return recipient
}

func decryptFile(encrypted string, identities []age.Identity) *bytes.Buffer {
	f, err := os.Open(encrypted)
	if err != nil {
		log.Fatalf("Failed to open file to decrypt (%s): %v", encrypted, err)
	}
	defer f.Close()
	armorReader := armor.NewReader(f)
	r, err := age.Decrypt(armorReader, identities...)
	if err != nil {
		log.Fatalf("Failed to open encrypted file: %v", err)
	}
	out := &bytes.Buffer{}
	if _, err := io.Copy(out, r); err != nil {
		log.Fatalf("Failed to read encrypted file: %v", err)
	}
	f.Close()
	return out
}

func encryptFile(encrypted string, recipient []age.Recipient, reader io.Reader) {
	f, err := os.Create(encrypted)
	if err != nil {
		log.Fatalf("Failed to open file to encrypt (%s): %v", encrypted, err)
	}
	defer f.Close()

	armorWriter := armor.NewWriter(f)
	defer armorWriter.Close()

	w, err := age.Encrypt(armorWriter, recipient...)
	if err != nil {
		log.Fatalf("Failed to open encryption file: %v", err)
	}
	defer w.Close()

	if _, err := io.Copy(w, reader); err != nil {
		log.Fatalf("Failed to write encrypted file: %v", err)
	}
}

func createSourceFile(goFilePath string, config templateConfig) {
	goFile, err := os.Create(goFilePath)
	if err != nil {
		panic(err)
	}
	defer goFile.Close()

	tmp, err := template.New("encthing").Parse(templateString)
	if err != nil {
		panic(err)
	}
	err = tmp.Execute(goFile, config)
	if err != nil {
		panic(err)
	}
}

func writeEncryptedSecret(filePath, key string, plain io.Reader) {
	of, err := os.Create(filePath)
	if err != nil {
		panic(err)
	}
	rcpt, err := age.NewScryptRecipient(key)
	if err != nil {
		panic(err)
	}
	aof := armor.NewWriter(of)
	defer aof.Close()
	w, err := age.Encrypt(aof, rcpt)
	if err != nil {
		panic(err)
	}
	defer w.Close()
	io.Copy(w, plain)
}

func build(IdentitiesFilePath, SecretFilePath, PackageName, VarName string) {
	goFilePath := strings.Join([]string{strings.TrimSuffix(SecretFilePath, ".asc"), "go"}, ".")
	if _, err := os.Stat(goFilePath); !errors.Is(err, os.ErrNotExist) {
		return
	}

	embedFilePath := strings.TrimSuffix(goFilePath, ".go")
	if _, err := os.Stat(embedFilePath); !errors.Is(err, os.ErrNotExist) {
		return
	}

	config := templateConfig{
		Key:              sCryptKeyGen(),
		PackageName:      PackageName,
		DecryptedVarName: VarName,
		EncryptedVarName: VarName + "Secrect",
		FunctionName:     VarName + "Decrypt",
		EmbedFileName:    filepath.Base(embedFilePath),
	}

	ident := identity(IdentitiesFilePath)
	plain := decryptFile(SecretFilePath, ident)
	createSourceFile(goFilePath, config)
	writeEncryptedSecret(embedFilePath, config.Key, plain)
}

func keygen(IdentitiesFilePath, RecipientsFilePath string) {
	if _, err := os.Stat(IdentitiesFilePath); !errors.Is(err, os.ErrNotExist) {
		log.Fatalf("IdentityFile exists: %s", IdentitiesFilePath)
	}

	k, err := age.GenerateX25519Identity()
	if err != nil {
		log.Fatalf("internal error: %v", err)
	}

	sb := strings.Builder{}
	sb.WriteString("# created: ")
	sb.WriteString(time.Now().Format(time.RFC3339))
	sb.WriteRune('\n')
	sb.WriteString("# public key: ")
	sb.WriteString(k.Recipient().String())
	sb.WriteRune('\n')
	sb.WriteString(k.String())
	sb.WriteRune('\n')

	passphrase, err := passphrasePromptForEncryption()
	if err != nil {
		log.Fatalf("Passphrase: %v", err)
	}
	writeEncryptedSecret(IdentitiesFilePath, passphrase, bytes.NewBufferString(sb.String()))

	flags := os.O_WRONLY | os.O_EXCL
	if _, err := os.Stat(RecipientsFilePath); errors.Is(err, os.ErrNotExist) {
		flags |= os.O_CREATE
	} else {
		flags |= os.O_APPEND
	}

	recipientsFile, err := os.OpenFile(RecipientsFilePath, flags, 0600)
	if err != nil {
		log.Fatal(err)
	}
	defer recipientsFile.Close()

	fmt.Fprintf(recipientsFile, "# %s\n", os.Getenv("USERNAME"))
	fmt.Fprintf(recipientsFile, "%s\n", k.Recipient())
}

func encrypt(RecipientsFilePath, PlainFilePath, SecretFilePath string) {
	r, err := os.Open(PlainFilePath)
	if err != nil {
		log.Fatalf("encrypt: '%s' - %v", PlainFilePath, err)
	}
	defer r.Close()

	recipients := recipient(RecipientsFilePath)
	encryptFile(SecretFilePath, recipients, r)
}

func recrypt(IdentitiesFilePath, RecipientsFilePath string, ConfidentialFilePaths []string) {
	ident := identity(IdentitiesFilePath)
	recipients := recipient(RecipientsFilePath)
	wd, _ := os.Getwd()
	for _, ConfidentialFilePath := range ConfidentialFilePaths {
		log.Println("recrypt", filepath.Join(wd, ConfidentialFilePath))
		plain := decryptFile(ConfidentialFilePath, ident)
		encryptFile(ConfidentialFilePath, recipients, plain)
	}
}

func masterRecrypt(IdentitiesFilePath, RecipientsFilePath string, ConfidentialFilePaths []string) {
	ident := master(IdentitiesFilePath)
	recipients := recipient(RecipientsFilePath)
	wd, _ := os.Getwd()
	for _, ConfidentialFilePath := range ConfidentialFilePaths {
		log.Println("recrypt", filepath.Join(wd, ConfidentialFilePath))
		plain := decryptFile(ConfidentialFilePath, ident)
		encryptFile(ConfidentialFilePath, recipients, plain)
	}
}

func decrypt(IdentitiesFilePath string, ConfidentialFilePaths []string) {
	ident := identity(IdentitiesFilePath)
	wd, _ := os.Getwd()
	for _, ConfidentialFilePath := range ConfidentialFilePaths {
		log.Println("decrypt", filepath.Join(wd, ConfidentialFilePath))

		plainFile := strings.TrimSuffix(ConfidentialFilePath, ".asc")
		f, err := os.Create(plainFile)
		if err != nil {
			log.Fatalf("Failed to open file to decrypt (%s): %v", plainFile, err)
		}
		defer f.Close()

		plain := decryptFile(ConfidentialFilePath, ident)
		_, err = io.Copy(f, plain)
		if err != nil {
			log.Fatalf("Failed to write bytes to decrypted file (%s): %v", plainFile, err)
		}
	}
}

type Flags struct {
	IdentitiesFile    string
	RecipientsFile    string
	SecretFile        string
	PlainFile         string
	PackageName       string
	VariableName      string
	Task              string
	ConfidentialFiles []string
}

func init() {
	log.SetFlags(0)
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage of '%s':\n", filepath.Base(os.Args[0]))
		flag.PrintDefaults()
	}
}

func main() {
	flags := &Flags{}
	flag.StringVar(&flags.IdentitiesFile, "i", "", "identities (shorthand)")
	flag.StringVar(&flags.RecipientsFile, "r", "", "recipient (shorthand)")

	flag.StringVar(&flags.Task, "task", "keygen", "the task which is executed\none of: keygen,build,encrypt,recrypt\n")
	flag.StringVar(&flags.SecretFile, "secret", "secret.txt", "file with encrypted secret\nused by: encrypt,recrypt,decrypt,build")
	flag.StringVar(&flags.PlainFile, "plain", "plain.txt", "plain clear input file\nused by: encrypt")
	flag.StringVar(&flags.IdentitiesFile, "identities", "identity.key", "Path to file with Identities\nused by: keygen,encrypt,recrypt\n")
	flag.StringVar(&flags.RecipientsFile, "recipients", "recipients.key", "Path to file with Recipients\nused by: keygen,recrypt,build\n")
	flag.StringVar(&flags.PackageName, "pkg", "main", "Path to file with Recipients\nused by: build\n")
	flag.StringVar(&flags.VariableName, "var", "secret", "Path to file with Recipients\nused by: build\n")
	flag.Func("confidential", "files with confidential to recrypt with new recipients", func(value string) error { flags.ConfidentialFiles = append(flags.ConfidentialFiles, value); return nil })
	flag.Parse()

	switch flags.Task {
	case "keygen":
		keygen(flags.IdentitiesFile, flags.RecipientsFile)
	case "encrypt":
		encrypt(flags.RecipientsFile, flags.PlainFile, flags.SecretFile)
	case "master-recrypt":
		masterRecrypt(flags.IdentitiesFile, flags.RecipientsFile, flags.ConfidentialFiles)
	case "recrypt":
		recrypt(flags.IdentitiesFile, flags.RecipientsFile, flags.ConfidentialFiles)
	case "decrypt":
		decrypt(flags.IdentitiesFile, flags.ConfidentialFiles)
	case "build":
		build(flags.IdentitiesFile, flags.SecretFile, flags.PackageName, flags.VariableName)
	}
}

//!
//! Code from [age ](https://github.com/FiloSottile/age)
//!
func passphrasePromptForEncryption() (string, error) {
	pass, err := readPassphrase("Enter passphrase (leave empty to autogenerate a secure one):")
	if err != nil {
		return "", fmt.Errorf("could not read passphrase: %v", err)
	}
	p := string(pass)
	if p == "" {
		var words []string
		for i := 0; i < 10; i++ {
			words = append(words, randomWord())
		}
		p = strings.Join(words, "-")
		// TODO: consider printing this to the terminal, instead of stderr.
		fmt.Fprintf(os.Stderr, "Using the autogenerated passphrase %q.\n", p)
	} else {
		confirm, err := readPassphrase("Confirm passphrase:")
		if err != nil {
			return "", fmt.Errorf("could not read passphrase: %v", err)
		}
		if string(confirm) != p {
			return "", fmt.Errorf("passphrases didn't match")
		}
	}
	return p, nil
}

// readPassphrase reads a passphrase from the terminal. It does not read from a
// non-terminal stdin, so it does not check stdinInUse.
func readPassphrase(prompt string) ([]byte, error) {
	var in, out *os.File
	if runtime.GOOS == "windows" {
		var err error
		in, err = os.OpenFile("CONIN$", os.O_RDWR, 0)
		if err != nil {
			return nil, err
		}
		defer in.Close()
		out, err = os.OpenFile("CONOUT$", os.O_WRONLY, 0)
		if err != nil {
			return nil, err
		}
		defer out.Close()
	} else if _, err := os.Stat("/dev/tty"); err == nil {
		tty, err := os.OpenFile("/dev/tty", os.O_RDWR, 0)
		if err != nil {
			return nil, err
		}
		defer tty.Close()
		in, out = tty, tty
	} else {
		if !term.IsTerminal(int(os.Stdin.Fd())) {
			return nil, fmt.Errorf("standard input is not a terminal, and /dev/tty is not available: %v", err)
		}
		in, out = os.Stdin, os.Stderr
	}
	fmt.Fprintf(out, "%s ", prompt)
	// Use CRLF to work around an apparent bug in WSL2's handling of CONOUT$.
	// Only when running a Windows binary from WSL2, the cursor would not go
	// back to the start of the line with a simple LF. Honestly, it's impressive
	// CONIN$ and CONOUT$ even work at all inside WSL2.
	defer fmt.Fprintf(out, "\r\n")
	return term.ReadPassword(int(in.Fd()))
}

func passphrasePrompt() (string, error) {
	pass, err := readPassphrase("Enter passphrase:")
	if err != nil {
		return "", fmt.Errorf("could not read passphrase: %v", err)
	}
	return string(pass), nil
}

// Copyright 2019 Google LLC
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd
func randomWord() string {
	buf := make([]byte, 2)
	if _, err := rand.Read(buf); err != nil {
		panic(err)
	}
	n := binary.BigEndian.Uint16(buf)
	return wordlist[int(n)%2048]
}

// wordlist is the BIP39 list of 2048 english words, and it's used to generate
// the suggested passphrases.
//go:embed wordlist
var _wordlist string
var wordlist = strings.Split(_wordlist, "\n")
